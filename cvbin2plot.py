#!/usr/bin/python3

##
#   cvbin2plot.py - Paul Derry
#   This script reads a BIN file generated by the Bioanalytical Systems CV-50W Voltammetric Analyzer and produces a
#   CSV file alongside a PNG plot of the CV curve based on the number of segments desired.
#   Flags for use include:
#   positional arguments:
#   binpath               path to the BIN file.
#
#   optional arguments:
#   -h, --help            show this help message and exit
#   --show-plot           show the MATPLOTLIB plot UI.
#   --clean-title         removes trailing extensions for the title. This might
#                         make certain people happy.
#   --segments= SEGMENTS  processes only N segments in the data, useful for
#                         showing the first full cycle in materials that are not
#                         electrochemically reversible.
##

import csv, array, struct, math, argparse, glob
import matplotlib.pyplot as plt
import numpy as np
import os.path

class CVBin:
    def __init__(self, path):
        self.path = path
        self.bin_date = ""
        self.bin_time = ""
        self.bin_label = ""
        self.cvfile = open(path, "rb")

    def readString(self):
        strbuf = bytearray()
        currentByte = b'\x00'
        # Read the date the data was collected
        while (currentByte != b'\x0a'):
            currentByte = self.cvfile.read(1)
            strbuf.append(int.from_bytes(currentByte, byteorder="little"))
        return strbuf.decode("utf-8").rstrip()

    def processBinary(self):
        self.bin_date = self.readString()
        self.bin_time = self.readString()
        self.bin_label = self.readString() # We can't figure out how to work with this, so for now the cludge further down is still valid.
        # use this for the offset from the label, not sure it'll work with a real label, but we haven't figured out how to include one any way so oh well.
        endOfLabel = self.cvfile.tell()
        self.cvfile.seek(10,1) # Skip ahead 10 bytes
        self.initvoltage = struct.unpack("i",self.cvfile.read(4))[0]
        self.highvoltage = struct.unpack("i",self.cvfile.read(4))[0]
        self.lowvoltage = struct.unpack("i",self.cvfile.read(4))[0]
        self.cvfile.seek(20,1)
        # Skip ahead 19 bytes for the time being because
        # I don't know what those other fields are for and they probably aren't important for this application
        self.mvpersecond = struct.unpack("i",self.cvfile.read(4))[0]
        self.direction = struct.unpack("i", self.cvfile.read(4))[0] #This is 0 for some reason.
        self.segments = struct.unpack("i", self.cvfile.read(4))[0]
        self.sensitivity = struct.unpack("i", self.cvfile.read(4))[0]
        self.quiettime = struct.unpack("i", self.cvfile.read(4))[0]
        self.sampleinterval = struct.unpack("i", self.cvfile.read(4))[0]

        self.cvfile.seek(endOfLabel + 218,0) # Go to position 218 plus the offset of the endOfLabel from the start of the file.
        ## This is the cludge.
        # We really need to know what the offset of the newline character for the label sits
        # and base all of this stuff off of that.
        self.datapoints = struct.unpack("h", self.cvfile.read(2))[0]
        self.cvfile.seek(endOfLabel + 250,0) # Go to position 250 plus the offset of the endOfLabel from the start of the file. This is where the currents show up.
        self.current = []

        for i in range(0,self.datapoints):
            self.current.append(struct.unpack("f",self.cvfile.read(4))[0])

    def formatDirection(self):
        if (self.formatDirection == 0):
            return 'Negative'
        else:
            return 'Positive'

    def printReport(self):
        print('\n')
        print('Sample Collection Date and Time: {bindate} {bintime}'.format(bindate=self.bin_date, bintime=self.bin_time))
        print('Initial Potential (mV):\t\t {init}'.format(init=self.initvoltage))
        print('Upper Potential Limit (mV):\t {high}'.format(high=self.highvoltage))
        print('Lower Potential Limit (mV):\t {low}'.format(low=self.lowvoltage))
        print('Initial Direction:\t\t {dir}'.format(dir=self.formatDirection()))
        print('Scanning Segments:\t\t {segs}'.format(segs=self.segments))
        print('Sample Interval (mV):\t\t {interval}'.format(interval=self.sampleinterval))
        print('\n')

    def generateVoltages(self):

        # Check if the number of segments given as an argument is less than or equal to the total number of segments in the file.

        # Check if the number of segments is given as an argument.
        if (args.segments != None):
            if (args.segments <= self.segments):
                argsegments = args.segments
            else:
                print("Number of desired segments exceeds number of available segments. Defaulting to available segments as limit.")
                argsegments = self.segments
        else:
            argsegments = self.segments
        # We know the interval, direction, init, low, and high voltages as well as the number of segments.
        # Calculate number of values in the initial segment.

        # we know the initial direction, initial position, and end voltages.

        # Set up the postive/negative indicator.
        posneg = 0
        if (self.direction == 0):
            posneg = -1
        else:
            posneg = 1

        # Set up the list to hold the voltages.

        self.voltagelist = []

        # If posneg is negative, we're going from init to low.
        if (posneg == -1):
            pointsInitialSegment = math.floor(abs((self.lowvoltage) - self.initvoltage) / self.sampleinterval)
            #Add rounded evenly spaced voltages to the list of voltages from initvoltage to low voltage.
            self.voltagelist.extend(np.around(np.linspace(self.initvoltage - self.sampleinterval, self.lowvoltage + 1,pointsInitialSegment)).tolist())
            posneg = posneg * -1 # Flip the direction for the next segment.
        else:
            pointsInitialSegment = math.floor(abs((self.highvoltage) - self.initvoltage) / self.sampleinterval)
            #Add rounded evenly spaced voltages to the list of voltages from initvoltage to low voltage.
            self.voltagelist.extend(np.around(np.linspace(self.initvoltage + self.sampleinterval, self.highvoltage - 1,pointsInitialSegment)).tolist())
            posneg = posneg * -1 #flip the direction for the next segment.
        # Do the rest of the segments

        # if args.segments is given, then we need to make sure to adjust the number of segments we're going to do

        for i in range(1,argsegments):
            pointsInSegment = math.floor(abs(self.highvoltage - self.lowvoltage) / self.sampleinterval)
            if (posneg == -1):
                self.voltagelist.extend(np.around(np.linspace(self.highvoltage - 1, self.lowvoltage + 1, pointsInSegment)).tolist())
                posneg = posneg * -1
            else:
                self.voltagelist.extend(np.around(np.linspace(self.lowvoltage + 1, self.highvoltage - 1, pointsInSegment)).tolist())
                posneg = posneg * -1

        self.current.remove(self.current[0])

    ##
    # Generates a plot using the MATPLOTLIB library as a PNG with a 300 DPI output.
    # The Y-limits are given as -0.0011 and 0.0001. These can be changed using arguments at the command line.
    ##

    def generatePlot(self):
        plt.tight_layout()
        plt.xlabel("Potential (mV)")
        plt.ylabel("Current (A)")
        # Sets the absolute minimum to -0.0011 A
        plt.ylim(-0.0011,0.0001)
        plt.subplots_adjust(left=0.15)

        # This section is dependent on the --clean-title flag in the arguments list.
        # if true, remove the .BIN or other fiddly bits following the file name, which usually is a page number or experiment name. Be judicious on this part. Please.
        # if false, do not remove the .BIN or other fiddly bits.

        if (args.cleantitle == True):
            title = os.path.basename(self.path).rstrip('.BIN')
            plt.title(title)
        else:
            plt.title(self.path)

        plt.plot(self.voltagelist, self.current[0:len(self.voltagelist)])

        # This section is dependent upon the --show flag in the arguments list.
        # if true, then show the MATPLOTLIB plot dialog. If false, export a PNG of the file at 300 DPI.

        if (args.show == True):
            plt.show()
        else:
            plt.savefig(str(self.path.rstrip('.BIN') + ".png"), dpi=300, facecolor='w', edgecolor='w', orientation='landscape', format='png', transparent='false')

        plt.close()

    def generateCSV(self):
        with open(str(self.path.rstrip('.BIN') + '.csv'), 'w') as f:
            writer = csv.writer(f, dialect='unix') # Works for Office 2013-2016
            writer.writerow(['Potential (mV)', 'Current (A)'])
            for i in range(0, len(self.voltagelist)):
                writer.writerow([self.voltagelist[i],self.current[i]])


parser = argparse.ArgumentParser(description='Generate plots from CV-50W BIN files.')
parser.add_argument('path', metavar='binpath', type=str, help='path to the BIN file(s).')
parser.add_argument('--show-plot', dest='show', help='show the MATPLOTLIB plot UI.', action="store_true")
parser.add_argument('--clean-title', dest='cleantitle', help='removes trailing extensions for the title. This might make certain people happy.', action="store_true")
parser.add_argument('--segments=', type=int, dest='segments', help='processes only N segments in the data, useful for showing the first full cycle in materials that are not electrochemically reversible.')
parser.add_argument('--min-current=', type=int, dest='mincurrent', help='Minimum current given in Amperes.')
parser.add_argument('--max-current=', type=int, dest='maxcurrent', help='Maximum current given in Amperes.')
parser.add_argument('--min-potential=', type=int, dest='minpotential', help='Minimum potential given in Amperes.')
parser.add_argument('--max-potential=', type=int, dest='maxpotential', help='Maximum potential given in Amperes.')
parser.add_argument('--license', dest='printLicense', help='displays the licensing information for this script.')
args = parser.parse_args()


def printLicense():
    print('cvbin2plot - produces CSV and plot output of Bioanalytical Systems CV-50W Voltammetric Analyzer BIN files.')
    print('Copyright (C) 2018 Paul J. Derry')
    print('This program is free software: you can redistribute it and/or modify')
    print('it under the terms of the GNU General Public License as published by')
    print('the Free Software Foundation, either version 3 of the License, or')
    print('(at your option) any later version.')
    print()
    print('This program is distributed in the hope that it will be useful,')
    print('but WITHOUT ANY WARRANTY; without even the implied warranty of')
    print('MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the')
    print('GNU General Public License for more details.')
    print('You should have received a copy of the GNU General Public License')
    print('along with this program.  If not, see <https://www.gnu.org/licenses/>.')


def main():


    filelist = glob.glob(args.path)
    print(filelist)
    for file in filelist:
        cvbin = CVBin(file)
        cvbin.processBinary()
        cvbin.printReport()
        cvbin.generateVoltages()
        cvbin.generatePlot()
        cvbin.generateCSV()
        del cvbin


if __name__ == "__main__": main()
